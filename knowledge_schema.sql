-- ============================================================================
-- FEAT SNIPER NEXUS - Knowledge Schema for Supabase
-- ============================================================================
-- This schema implements the Cross-Asset Intelligence Architecture.
-- Knowledge is classified as UNIVERSAL (applies to all assets) or
-- SPECIFIC (applies to particular asset/class).
-- ============================================================================

-- ============================================================================
-- KNOWLEDGE SCOPE ENUM
-- ============================================================================
DO $$ BEGIN
    CREATE TYPE knowledge_scope AS ENUM ('UNIVERSAL', 'ASSET_SPECIFIC', 'CLASS_SPECIFIC');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
    CREATE TYPE asset_class AS ENUM ('METAL', 'FOREX', 'CRYPTO', 'INDEX', 'COMMODITY');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

-- ============================================================================
-- KNOWLEDGE BASE TABLE
-- Stores insights, patterns, and learnings
-- ============================================================================
CREATE TABLE IF NOT EXISTS knowledge_base (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    
    -- Classification
    scope knowledge_scope NOT NULL DEFAULT 'UNIVERSAL',
    asset_class asset_class NULL,
    symbol VARCHAR(20) NULL,
    
    -- Content
    category VARCHAR(50) NOT NULL, -- 'FEAT_PATTERN', 'EMA_CROSS', 'KILLZONE', etc.
    title VARCHAR(200) NOT NULL,
    content TEXT NOT NULL,
    
    -- Metrics
    confidence DECIMAL(3,2) DEFAULT 0.50, -- 0.00 to 1.00
    times_validated INTEGER DEFAULT 0,
    times_failed INTEGER DEFAULT 0,
    
    -- Vector embedding for RAG
    embedding VECTOR(384) NULL,
    
    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    last_used_at TIMESTAMPTZ NULL
);

-- Indexes for fast retrieval
CREATE INDEX IF NOT EXISTS idx_knowledge_scope ON knowledge_base(scope);
CREATE INDEX IF NOT EXISTS idx_knowledge_class ON knowledge_base(asset_class);
CREATE INDEX IF NOT EXISTS idx_knowledge_symbol ON knowledge_base(symbol);
CREATE INDEX IF NOT EXISTS idx_knowledge_category ON knowledge_base(category);

-- ============================================================================
-- ASSET PROFILES TABLE
-- Stores volatility, pip values, and asset-specific parameters
-- ============================================================================
CREATE TABLE IF NOT EXISTS asset_profiles (
    symbol VARCHAR(20) PRIMARY KEY,
    asset_class asset_class NOT NULL,
    
    -- Normalization parameters
    pip_value DECIMAL(10,6) NOT NULL,
    typical_atr_m5 DECIMAL(15,5) NOT NULL, -- Typical ATR on M5 timeframe
    spread_tolerance_atr DECIMAL(5,3) DEFAULT 0.10,
    
    -- Trading characteristics
    killzones TEXT[] DEFAULT ARRAY['LONDON', 'NY'],
    correlations TEXT[] DEFAULT ARRAY[]::TEXT[],
    
    -- Volatility tracking
    current_atr DECIMAL(15,5) NULL,
    atr_percentile INTEGER NULL, -- 0-100, current ATR vs historical
    
    -- Updated tracking
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Insert default asset profiles
INSERT INTO asset_profiles (symbol, asset_class, pip_value, typical_atr_m5, killzones, correlations)
VALUES 
    ('XAUUSD', 'METAL', 0.01, 2.5, ARRAY['LONDON', 'NY'], ARRAY['XAGUSD', 'DXY_inverse']),
    ('EURUSD', 'FOREX', 0.0001, 0.0015, ARRAY['LONDON', 'NY'], ARRAY['GBPUSD', 'DXY_inverse']),
    ('GBPUSD', 'FOREX', 0.0001, 0.0018, ARRAY['LONDON', 'NY'], ARRAY['EURUSD']),
    ('BTCUSD', 'CRYPTO', 1.0, 150.0, ARRAY['ASIA', 'NY'], ARRAY['ETHUSD']),
    ('US30', 'INDEX', 1.0, 50.0, ARRAY['NY'], ARRAY['SPX', 'NASDAQ'])
ON CONFLICT (symbol) DO NOTHING;

-- ============================================================================
-- TRADING SIGNALS TABLE
-- Logs all signals generated by the ML engine
-- ============================================================================
CREATE TABLE IF NOT EXISTS trading_signals (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    
    -- Context
    symbol VARCHAR(20) NOT NULL,
    timeframe VARCHAR(5) NOT NULL,
    
    -- Signal
    direction VARCHAR(10) NOT NULL, -- 'BUY', 'SELL', 'WAIT'
    confidence DECIMAL(3,2) NOT NULL,
    
    -- ML Details
    ml_source VARCHAR(20), -- 'GBM', 'LSTM', 'ENSEMBLE'
    p_win DECIMAL(4,3),
    anomaly_score DECIMAL(4,3),
    is_anomaly BOOLEAN DEFAULT FALSE,
    
    -- FEAT Context
    feat_score DECIMAL(5,2),
    fsm_state VARCHAR(20),
    
    -- Market Context (normalized)
    price DECIMAL(15,5),
    atr DECIMAL(15,5),
    rsi DECIMAL(5,2),
    
    -- Execution
    execution_enabled BOOLEAN DEFAULT FALSE,
    executed BOOLEAN DEFAULT FALSE,
    execution_result JSONB NULL,
    
    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index for time-based queries
CREATE INDEX IF NOT EXISTS idx_signals_symbol_time ON trading_signals(symbol, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_signals_executed ON trading_signals(executed) WHERE executed = TRUE;

-- ============================================================================
-- PATTERN OUTCOMES TABLE
-- Tracks success/failure of specific patterns for learning
-- ============================================================================
CREATE TABLE IF NOT EXISTS pattern_outcomes (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    
    -- Pattern reference
    knowledge_id UUID REFERENCES knowledge_base(id),
    signal_id UUID REFERENCES trading_signals(id),
    
    -- Context
    symbol VARCHAR(20) NOT NULL,
    pattern_category VARCHAR(50) NOT NULL,
    
    -- Outcome
    outcome VARCHAR(10) NOT NULL, -- 'WIN', 'LOSS', 'BREAKEVEN'
    pnl_atr DECIMAL(6,3), -- PnL in ATR units (normalized)
    
    -- Timestamps
    entry_time TIMESTAMPTZ NOT NULL,
    exit_time TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ============================================================================
-- RLS POLICIES (Row Level Security)
-- ============================================================================
ALTER TABLE knowledge_base ENABLE ROW LEVEL SECURITY;
ALTER TABLE asset_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE trading_signals ENABLE ROW LEVEL SECURITY;
ALTER TABLE pattern_outcomes ENABLE ROW LEVEL SECURITY;

-- Allow service role full access
CREATE POLICY "Service role has full access" ON knowledge_base
    FOR ALL USING (auth.role() = 'service_role');
    
CREATE POLICY "Service role has full access" ON asset_profiles
    FOR ALL USING (auth.role() = 'service_role');
    
CREATE POLICY "Service role has full access" ON trading_signals
    FOR ALL USING (auth.role() = 'service_role');
    
CREATE POLICY "Service role has full access" ON pattern_outcomes
    FOR ALL USING (auth.role() = 'service_role');

-- ============================================================================
-- FUNCTIONS
-- ============================================================================

-- Get knowledge by scope and optional asset filter
CREATE OR REPLACE FUNCTION get_relevant_knowledge(
    p_symbol VARCHAR(20),
    p_category VARCHAR(50) DEFAULT NULL
)
RETURNS TABLE (
    id UUID,
    scope knowledge_scope,
    category VARCHAR(50),
    title VARCHAR(200),
    content TEXT,
    confidence DECIMAL(3,2)
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        kb.id,
        kb.scope,
        kb.category,
        kb.title,
        kb.content,
        kb.confidence
    FROM knowledge_base kb
    LEFT JOIN asset_profiles ap ON ap.symbol = p_symbol
    WHERE 
        -- Universal knowledge applies to all
        kb.scope = 'UNIVERSAL'
        -- Asset-specific knowledge
        OR (kb.scope = 'ASSET_SPECIFIC' AND kb.symbol = p_symbol)
        -- Class-specific knowledge
        OR (kb.scope = 'CLASS_SPECIFIC' AND kb.asset_class = ap.asset_class)
    AND (p_category IS NULL OR kb.category = p_category)
    ORDER BY kb.confidence DESC, kb.updated_at DESC;
END;
$$ LANGUAGE plpgsql;


-- Update pattern confidence based on outcomes
CREATE OR REPLACE FUNCTION update_pattern_confidence()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE knowledge_base
    SET 
        times_validated = times_validated + CASE WHEN NEW.outcome = 'WIN' THEN 1 ELSE 0 END,
        times_failed = times_failed + CASE WHEN NEW.outcome = 'LOSS' THEN 1 ELSE 0 END,
        confidence = CASE 
            WHEN (times_validated + times_failed) > 0 
            THEN times_validated::DECIMAL / (times_validated + times_failed)
            ELSE 0.50
        END,
        updated_at = NOW()
    WHERE id = NEW.knowledge_id;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_pattern_confidence
    AFTER INSERT ON pattern_outcomes
    FOR EACH ROW
    EXECUTE FUNCTION update_pattern_confidence();

-- ============================================================================
-- VIEWS
-- ============================================================================

-- Knowledge performance by category
CREATE OR REPLACE VIEW knowledge_performance AS
SELECT 
    category,
    scope,
    COUNT(*) as total_patterns,
    AVG(confidence) as avg_confidence,
    SUM(times_validated) as total_wins,
    SUM(times_failed) as total_losses
FROM knowledge_base
GROUP BY category, scope;

-- Signal accuracy by symbol
CREATE OR REPLACE VIEW signal_accuracy AS
SELECT 
    symbol,
    COUNT(*) as total_signals,
    AVG(confidence) as avg_confidence,
    SUM(CASE WHEN executed THEN 1 ELSE 0 END) as executed_count,
    AVG(CASE WHEN is_anomaly THEN 1 ELSE 0 END) as anomaly_rate
FROM trading_signals
WHERE created_at > NOW() - INTERVAL '7 days'
GROUP BY symbol;
